name: Auto-label New Issues

on:
  issues:
    types:
      - opened
      - reopened

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Apply labels based on issue content
        uses: actions/github-script@v7
        with:
          script: |
            function classifyIssue(title, body) {
              const text = (title + ' ' + (body || '')).toLowerCase();
              const labels = [];

              // Bug indicators
              const bugPatterns = [
                /\bbug\b/, /\berror\b/, /\bfail(ed|ure|s)?\b/, /\bbroken\b/, /\bcrash\b/,
                /doesn'?t (work|seem|do|show|open|save|load|register|update|stay|function)/,
                /does not (work|open|save|load|register|update|stay|function|do)/,
                /not working/, /won'?t/, /can'?t/, /cannot/,
                /not (being )?(saved|created|updating|working|loading|registering|staying|recognized)/,
                /aren'?t (working|registering|showing|loading|saving|updating)/,
                /unable to/, /failed to (load|install)/, /plugin fail/,
                /wipes?\b/, /wiped\b/, /wont/, /doesn'?t do anything/,
                /nothing happens/, /no such file/, /enoent/,
              ];
              if (bugPatterns.some(p => p.test(text))) {
                labels.push('bug');
              }

              // Enhancement / Feature request indicators
              // NOTE: keep these patterns in sync with setup-labels.yml
              const enhancementPatterns = [
                /\brequest\b/, /\bsuggestions?\b/, /\bideas?\b/, /\benhancement\b/,
                /\bimprovement\b/, /add support/, /\bfeature\b/, /\boffer\b/,
                /would (it )?be (possible|nice|great|cool)/, /\bwish\b/,
                /\bproposal\b/, /\bideally\b/, /\[request\]/i,
              ];
              if (enhancementPatterns.some(p => p.test(text))) {
                // Always add 'feature request'; add 'enhancement' only for non-bug issues
                labels.push('feature request');
                if (!labels.includes('bug')) {
                  labels.push('enhancement');
                }
              }

              // Documentation indicators
              const docPatterns = [
                /\bdocumentation\b/, /\bdocs\b/, /\bguide\b/, /\btutorial\b/,
                /\bcss\b/, /css adjustment/, /visual adjustment/, /\bsnippet\b/,
              ];
              if (docPatterns.some(p => p.test(text))) {
                labels.push('documentation');
              }

              // Question / help indicators
              const questionPatterns = [
                /\?/, /\bquestion\b/, /is there a way/, /how (to|do i|can i)/,
                /is it possible/, /\bmanaging\b/, /\bhow\b.*\bwork/,
                /is there a setting/, /is it implemented/,
              ];
              if (questionPatterns.some(p => p.test(text))) {
                labels.push('question');
              }

              // Help wanted
              const helpPatterns = [
                /\bhelp\b/, /\bstuck\b/, /\bconfused\b/,
                /failed to (install|load)/, /installation fail/,
                /help wanted/, /can'?t install/,
              ];
              if (helpPatterns.some(p => p.test(text))) {
                labels.push('help wanted');
              }

              return [...new Set(labels)];
            }

            const issue = context.payload.issue;
            const labels = classifyIssue(issue.title, issue.body);

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels,
              });
              console.log(`Applied labels [${labels.join(', ')}] to issue #${issue.number}`);
            } else {
              console.log(`No labels matched for issue #${issue.number}`);
            }
